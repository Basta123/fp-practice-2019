module Task4_1 where

{-
  Задание 4.1
  Реализация монады над функцией.
  Реализуйте все требуемые классы типов и объясните, почему они реализованы именно так.
-}

-- Монада над функцией. В качестве входного значения `fun` может быть что угодно
-- Собственно, почему бы не `String`?
data FunMonad a = FunMonad { fun :: String -> a }

-- реализуйте классы `Functor`, `Applicative` и `Monad` для типа `FunMonad`


instance Functor FunMonad where
   {- 
  Класс типов Функтор имеет только один метод, а именно fmap.
  функция fmap принимет произвольную функцию и контейнерный тип(например maybe) с элементом(элементами),
  возвращая тот же контейнер с преобразованными элементом(элементами). То есть получается, что функция fmap принимает функцию, которая  применяется к каждому элементу контейнера
  возвращая необходимый результат, который затем упаковывается в наш контейнер. функция fmap в отличие от map работает не с примитивными типами, а с контейнерами(типами высших порядков). Также 
  fmap можно использовать в инфиксным стиле, например `fmap` или же <$>. 
  -}
  fmap foo (FunMonad fun) = FunMonad (foo . fun)
  
  
  
instance Applicative FunMonad where
  
  {-Функция pure достаточно простая, она берёт значение (которое является функцией) и оборачивает его в АФ-обёртку для последующей работы с ней.
  её тип выглядит очень прост: a -> f a, то есть мы просто оборачиваем наш аргумент в обертку. -}
  pure foo = FunMonad (\arg -> foo) -- так на выходе мы просто получаем нашу функцию упакованную в функтор
  
  
  {-
  основной оператор АП кроме принимаемого аргумента оборачивает в контекст также принимаемую функцию, то есть
  если fmap имеет следующий тип (a -> b) -> f a -> f b, то оператор последовательного применения <*> имеет тип 
  (<*>) :: f (a -> b) -> f a -> f b, то есть функция также оборачивается в обертку. То есть оператор <*> излвлекает 
  функцию из первого функтора и применяет ко значению второго функтора, в итоге мы получаем результат в функторе(Обертке, контексте). 
   -}
  
  
  (<*>) (FunMonad funLeft) (FunMonad funRight) = FunMonad (\arg -> funLeft arg $ funRight arg)



instance Monad FunMonad where
    -- return можно сравниить с функцией pure, return упаковывает значение(функцию) в монаду(к примеру Maybe).
   return f = FunMonad(\arg -> f)
   -- оператор разворачивает аргумент, к которому применяется функция, возвращая результат в обертке
   (>>=) (FunMonad func) f = FunMonad(\arg -> fun (f (func arg)) arg)
  
